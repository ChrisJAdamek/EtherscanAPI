<!DOCTYPE html>
<html>
  <head>
    <title>Etherscan API - Transaction List</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      #results {
        margin-top: 20px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>Etherscan API - Transaction List</h1>
    <label for="apiKey">Enter your Etherscan API Key:</label>
    <input type="text" id="apiKey" placeholder="Your API Key">
    <br>
    <label for="address">Enter Ethereum addresses (comma-separated):</label>
    <input type="text" id="address" placeholder="0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae, 0x742d35Cc6634C0532925a3b844Bc454e4438f44e">
    <button id="fetchTransactions">Fetch Transactions</button>

    <div id="summary"></div>
    <div id="results"></div>
<script>
    document.getElementById('fetchTransactions').addEventListener('click', fetchTransactions);

    async function getAllTransactions(fetchTransactionsFunction, addresses, transactionType, apiKey, addressTransactionCounts) {
        const promises = addresses.map(async (address, index) => {
            await new Promise(resolve => setTimeout(resolve, index * 400));
            return fetchTransactionsFunction(address, transactionType, apiKey);
        });

        return Promise.all(promises).then(results => {
            const allTransactions = results.flatMap(r => r.transactions);
            results.forEach((curr, index) => {
                addressTransactionCounts[addresses[index]] += curr.transactionCount;
            });

            return { allTransactions, addressTransactionCounts };
        });
    }

    function initializeAddressTransactionCounts(addresses) {
        const addressTransactionCounts = {};
        addresses.forEach(address => addressTransactionCounts[address] = 0);
        return addressTransactionCounts;
    }

    async function fetchTransactions() {
        const apiKey = document.getElementById('apiKey').value;
        const inputAddresses = document.getElementById('address').value;
        const addresses = inputAddresses.split(',').map(a => a.trim());

        const transactionEndpoints = [
            { transactionType: 'txlist', fetchTransactionsFunction: fetchAccountActivity },
            { transactionType: 'txlistinternal', fetchTransactionsFunction: fetchAccountActivity },
            { transactionType: 'tokentx', fetchTransactionsFunction: fetchAccountActivity },
            { transactionType: 'tokennfttx', fetchTransactionsFunction: fetchAccountActivity },
            { transactionType: 'token1155tx', fetchTransactionsFunction: fetchAccountActivity },
        ];

        const allTransactions = [];
        const addressTransactionCounts = initializeAddressTransactionCounts(addresses);

        for (const transactionEndpoint of transactionEndpoints) {
            const { allTransactions: transactions, addressTransactionCounts: transactionCounts } = await getAllTransactions(transactionEndpoint.fetchTransactionsFunction, addresses, transactionEndpoint.transactionType, apiKey, addressTransactionCounts);

            allTransactions.push(...transactions);
            await new Promise(resolve => setTimeout(resolve, 1000));
        }

        displaySummary(addressTransactionCounts, allTransactions.length);
        displayTransactions(allTransactions);
    }

    function buildURL(transactionType, address, apiKey) {
        return `https://api.etherscan.io/api?module=account&action=${transactionType}&address=${address}&startblock=0&endblock=latest&page=1&offset=10000&sort=asc&apikey=${apiKey}`;
    }

    async function fetchData(transactionType, address, apiKey, retries = 3) {
        const url = buildURL(transactionType, address, apiKey);
        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.status === "0" && data.message === "NOTOK" && data.result === "Max rate limit reached" && retries > 0) {
                console.warn("Max rate limit reached. Retrying...");
                await new Promise(resolve => setTimeout(resolve, 1000));
                return await fetchData(transactionType, address, apiKey, retries - 1);
            }

            return data;
        } catch (error) {
            console.error("Error fetching data:", error);
            return { result: [] };
        }
    }

    async function fetchAccountActivity(address, transactionType, apiKey) {
        try {
            const data = await fetchData(transactionType, address, apiKey);
            const type = transactionType === 'txlist' ? 'normal' : transactionType === 'txlistinternal' ? 'internal' : transactionType === 'tokentx' ? 'erc20' : transactionType === 'tokennfttx' ? 'erc721' : 'erc1155';
            const transactionMapper = tx => ({ ...tx, type });

            if (Array.isArray(data.result)) {
                return {
                    transactions: data.result.map(transactionMapper),
                    transactionCount: data.result.length,
                };
            } else {
                console.warn("Unexpected data format received:", data);
                return {
                    transactions: [],
                    transactionCount: 0,
                };
            }
        } catch (error) {
            console.error("Error fetching transactions and transfers:", error);
            return {
                transactions: [],
                transactionCount: 0,
            };
        }
    }

    function displaySummary(addressTransactionCounts, totalCount) {
        const summaryDiv = document.getElementById('summary');
        const summaryItems = Object.entries(addressTransactionCounts).map(([address, count]) => `Entries found for ${address}: ${count}<br>`);
        summaryDiv.innerHTML = `Total entries found: ${totalCount}<br>${summaryItems.join('')}`;
    }

    function displayTransactions(transactions) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';

        transactions.sort((a, b) => parseInt(a.timeStamp) - parseInt(b.timeStamp));

        const table = createTable(transactions);
        resultsDiv.appendChild(table);
    }

    function createTable(transactions) {
        const table = document.createElement('table');
        const rows = transactions.map(tx => createRow(tx)).join('');

        table.innerHTML = `
            <tr>
                <th>Type</th>
                <th>Timestamp</th>
                <th>TX Hash</th>
                <th>Value</th>
                <th>Token Symbol</th>
                <th>From</th>
                <th>To</th>
                <th>Contract Address</th>
                <th>TokenID</th>
                <th>TX Fee (ETH)</th>
                <th>Token Name</th>
                <th>Gas Price (Gwei)</th>
                <th>TX Failed</th>
            </tr>
            ${rows}
        `;

        return table;
    }

    function createRow(tx) {
        const value = getValue(tx);
        const tokenSymbol = getTokenSymbol(tx);
        const transactionFee = ((parseInt(tx.gasPrice) * parseInt(tx.gasUsed)) / 1e18).toFixed(6);

        return `
            <tr>
                <td>${tx.type}</td>
                <td>${new Date(tx.timeStamp * 1000).toLocaleString()}</td>
                <td>${tx.hash}</td>
                <td>${value}</td>
                <td>${tokenSymbol}</td>
                <td>${tx.from}</td>
                <td>${tx.to}</td>
                <td>${tx.contractAddress}</td>
                <td>${tx.tokenID || 'N/A'}</td>
                <td>${transactionFee}</td>
                <td>${tx.tokenName || 'N/A'}</td>
                <td>${(parseInt(tx.gasPrice) / 1e9).toFixed(6)}</td>
                <td>${tx.isError === '1' ? 'Yes' : 'No'}</td>
            </tr>
        `;
    }

    function getValue(tx) {
        if (['normal', 'internal', 'erc20'].includes(tx.type)) {
            return getEthOrErc20Value(tx);
        } else if (tx.type === 'erc721') {
            return 1;
        } else if (tx.type === 'erc1155') {
            return tx.tokenValue;
        }
    }

    function getEthOrErc20Value(tx) {
        const decimal = tx.type === 'erc20' && tx.tokenDecimal !== 'N/A' ? tx.tokenDecimal : 18;
        return (parseInt(tx.value) / Math.pow(10, decimal)).toFixed(6);
    }

    function getTokenSymbol(tx) {
        if (['internal', 'normal'].includes(tx.type)) {
            return 'ETH';
        } else if (tx.type === 'erc20') {
            return tx.tokenSymbol || 'N/A';
        } else if (['erc721', 'erc1155'].includes(tx.type)) {
            return `${tx.tokenSymbol}-${tx.tokenID}`;
        }
    }
</script>



  </body>
</html>
