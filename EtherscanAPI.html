<!DOCTYPE html>
<html>
  <head>
    <title>Etherscan API - Transaction List</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      #results {
        margin-top: 20px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <h1>Etherscan API - Transaction List</h1>
    <label for="apiKey">Enter your Etherscan API Key:</label>
    <input type="text" id="apiKey" placeholder="Your API Key">
    <br>
    <label for="address">Enter Ethereum addresses (comma-separated):</label>
    <input type="text" id="address" placeholder="0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae, 0x742d35Cc6634C0532925a3b844Bc454e4438f44e">
    <button id="fetchTransactions">Fetch Transactions</button>

    <div id="summary"></div>
    <div id="results"></div>
<script>
    document.getElementById('fetchTransactions').addEventListener('click', fetchTransactionsWithDelay);

	async function getAllTransactions(fetchFunction, addresses, action, apiKey, addressTransactionCounts) {
	    const promises = addresses.map(async (address, index) => {
		// Add a delay based on the index to spread out API requests
		await new Promise(resolve => setTimeout(resolve, index * 400)); // 400 ms between requests to avoid rate limit
		return fetchFunction(address, action, apiKey);
	    });

	    return Promise.all(promises).then(results => {
		const allTransactions = results.flatMap(r => r.transactions);
		results.forEach((curr, index) => {
		    addressTransactionCounts[addresses[index]] += curr.transactionCount;
		});

		return { allTransactions, addressTransactionCounts };
	    });
	}


    function initializeAddressTransactionCounts(addresses) {
        const addressTransactionCounts = {};
        addresses.forEach(address => addressTransactionCounts[address] = 0);
        return addressTransactionCounts;
    }

    async function fetchTransactionsWithDelay() {
        const apiKey = document.getElementById('apiKey').value;
        const inputAddresses = document.getElementById('address').value;
        const addresses = inputAddresses.split(',').map(a => a.trim());

        const transactionTypes = [
            { action: 'txlist', fetchFunction: fetchTransactionsAndTransfers },
            { action: 'txlistinternal', fetchFunction: fetchTransactionsAndTransfers },
            { action: 'tokentx', fetchFunction: fetchTransactionsAndTransfers },
            { action: 'tokennfttx', fetchFunction: fetchTransactionsAndTransfers },
            { action: 'token1155tx', fetchFunction: fetchTransactionsAndTransfers },
        ];

        const allTransactions = [];
	    const addressTransactionCounts = initializeAddressTransactionCounts(addresses);

	    for (const transactionType of transactionTypes) {
		const { allTransactions: transactions, addressTransactionCounts: transactionCounts } = await getAllTransactions(transactionType.fetchFunction, addresses, transactionType.action, apiKey, addressTransactionCounts);

		allTransactions.push(...transactions);
		await new Promise(resolve => setTimeout(resolve, 1000));
	    }

        displaySummary(addressTransactionCounts, allTransactions.length);
        displayTransactions(allTransactions);
    }

    function buildURL(action, address, apiKey) {
        return `https://api.etherscan.io/api?module=account&action=${action}&address=${address}&startblock=0&endblock=latest&page=1&offset=10000&sort=asc&apikey=${apiKey}`;
    }

	async function fetchData(action, address, apiKey, retries = 3) {
	    const url = buildURL(action, address, apiKey);
	    try {
		const response = await fetch(url);
		const data = await response.json();

		if (data.status === "0" && data.message === "NOTOK" && data.result === "Max rate limit reached" && retries > 0) {
		    console.warn("Max rate limit reached. Retrying...");
		    await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for 1 second before retrying
		    return await fetchData(action, address, apiKey, retries - 1);
		}

		return data;
	    } catch (error) {
		console.error("Error fetching data:", error);
		return { result: [] };
	    }
	}

	async function fetchTransactionsAndTransfers(address, action, apiKey) {
	    const data = await fetchData(action, address, apiKey);
	    const type = action === 'txlist' ? 'normal' : action === 'txlistinternal' ? 'internal' : action === 'tokentx' ? 'erc20' : action === 'tokennfttx' ? 'erc721' : 'erc1155';
	    const transactionMapper = tx => ({ ...tx, type });

	    if (Array.isArray(data.result)) {
		return {
		    transactions: data.result.map(transactionMapper),
		    transactionCount: data.result.length,
		};
	    } else {
		console.warn("Unexpected data format received:", data);
		return {
		    transactions: [],
		    transactionCount: 0,
		};
	    }
	}


	function displaySummary(addressTransactionCounts, totalCount) {
	    const summaryDiv = document.getElementById('summary');
	    const summaryItems = Object.entries(addressTransactionCounts).map(([address, count]) => `Entries found for ${address}: ${count}<br>`);
	    summaryDiv.innerHTML = `Total entries found: ${totalCount}<br>${summaryItems.join('')}`;
	}

	function displayTransactions(transactions) {
	    const resultsDiv = document.getElementById('results');
	    resultsDiv.innerHTML = '';

        transactions.sort((a, b) => parseInt(a.timeStamp) - parseInt(b.timeStamp));

        const table = createTable(transactions);
        resultsDiv.appendChild(table);
    }

    function createTable(transactions) {
        const table = document.createElement('table');
        const rows = transactions.map(tx => createRow(tx)).join('');

        table.innerHTML = `
            <tr>
                <th>Type</th>
                <th>Timestamp</th>
                <th>TX Hash</th>
                <th>Value</th>
                <th>Token Symbol</th>
                <th>From</th>
                <th>To</th>
                <th>Contract Address</th>
                <th>TokenID</th>
                <th>TX Fee (ETH)</th>
                <th>Token Name</th>
                <th>Gas Price (Gwei)</th>
                <th>TX Failed</th>
            </tr>
            ${rows}
        `;

        return table;
    }

    function createRow(tx) {
        const value = getValue(tx);
        const tokenSymbol = getTokenSymbol(tx);
        const transactionFee = ((parseInt(tx.gasPrice) * parseInt(tx.gasUsed)) / 1e18).toFixed(6);

        return `
            <tr>
                <td>${tx.type}</td>
                <td>${new Date(tx.timeStamp * 1000).toLocaleString()}</td>
                <td>${tx.hash}</td>
                <td>${value}</td>
                <td>${tokenSymbol}</td>
                <td>${tx.from}</td>
                <td>${tx.to}</td>
                <td>${tx.contractAddress}</td>
                <td>${tx.tokenID || 'N/A'}</td>
                <td>${transactionFee}</td>
                <td>${tx.tokenName || 'N/A'}</td>
                <td>${(parseInt(tx.gasPrice) / 1e9).toFixed(6)}</td>
                <td>${tx.isError === '1' ? 'Yes' : 'No'}</td>
            </tr>
        `;
    }

    function getValue(tx) {
        let value;
        if (tx.type === 'normal' || tx.type === 'internal' || tx.type === 'erc20') {
            value = (parseInt(tx.value) / ((tx.type === 'erc20' && tx.tokenDecimal !== 'N/A') ? Math.pow(10, tx.tokenDecimal) : 1e18)).toFixed(6);
        } else if (tx.type === 'erc721') {
            value = 1;
        } else if (tx.type === 'erc1155') {
            value = tx.tokenValue;
        }
        return value;
    }

    function getTokenSymbol(tx) {
        let tokenSymbol;
        if (tx.type === 'internal' || tx.type === 'normal') {
            tokenSymbol = 'ETH';
        } else if (tx.type === 'erc20') {
            tokenSymbol = tx.tokenSymbol || 'N/A';
        } else if (tx.type === 'erc721') {
            tokenSymbol = tx.tokenSymbol + '-' + tx.tokenID;
        } else if (tx.type === 'erc1155') {
            tokenSymbol = tx.tokenSymbol + '-' + tx.tokenID;
        }
        return tokenSymbol;
    }
</script>

  </body>
</html>
