<!DOCTYPE html>
<html>
  <head>
    <title>Etherscan API - Transaction List</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      #results {
        margin-top: 20px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
        font-weight: bold;
      }
    </style>
  </head>
<body>
  <h1>Etherscan API</h1>
  <label for="api-key">Enter your Etherscan API Key:</label>
  <input type="text" id="api-key" placeholder="Your API Key">
  <br>
  <label for="singleAddress">Enter Ethereum addresses (comma-separated):</label>
  <input type="text" id="singleAddress" placeholder="0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae, 0x742d35Cc6634C0532925a3b844Bc454e4438f44e">
  <button id="fetchAndDisplayTransactions">Fetch and Display Transactions</button>

  <div id="summary"></div>
  <div id="results"></div>
</body>

<script>
	document.addEventListener('DOMContentLoaded', () => {
		document.getElementById('fetchAndDisplayTransactions').addEventListener('click', fetchAndDisplayTransactions);
	});

class EtherscanApi {
	constructor(apiKey) {
		this.apiKey = apiKey;
		this.baseUrl = "https://api.etherscan.io/api";
	}

	async fetchTransactionDataWithPagination(args) {
	  const data = await this.fetchTransactionData(args);
	  if (data.length === 10000) {
	    console.log("Fetching next page...");
	    const nextPageData = await this.fetchTransactionDataWithPagination({
	      ...args,
	      page: args.page + 1,
	    });
	    return data.concat(nextPageData);
	  }
	  return data;
	}

	async fetchTransactionData({
	  singleTransactionType,
	  singleAddress,
	  page = 1,
	  retries = 3
	}) {
	  const url = this.buildURL(singleTransactionType, singleAddress, page);
	  try {
	    const response = await fetch(url);
	    const data = await response.json();

	    if (data.status === "0" && data.message === "NOTOK" && data.result === "Max rate limit reached" && retries > 0) {
	      console.warn("Max rate limit reached. Retrying...");
	      await new Promise(resolve => setTimeout(resolve, 1000));
	      return await this.fetchTransactionData({
		singleTransactionType,
		singleAddress,
		page,
		retries: retries - 1
	      });
	    }

	    return data.result;
	  } catch (error) {
	    console.error("Error fetching data:", error);
	    return [];
	  }
	}


	buildURL(singleTransactionType, singleAddress, page) {
		return `${this.baseUrl}?module=account&action=${singleTransactionType}&address=${singleAddress}&startblock=0&endblock=latest&page=${page}&offset=10000&sort=asc&apikey=${this.apiKey}`;
	}
}

function initializeAddressTransactionCounts(addresses) {
	const addressTransactionCounts = {};
	addresses.forEach(singleAddress => addressTransactionCounts[singleAddress] = 0);
	return addressTransactionCounts;
}

    async function fetchAndDisplayTransactions() {
        const etherscanApi = createEtherscanApi(); 
        const addresses = getInputAddresses(); 

        const addressTransactionCounts = initializeAddressTransactionCounts(addresses);
        const allTransactions = await fetchAllTransactions(addresses, addressTransactionCounts, etherscanApi);
        displayAllTransactions(addressTransactionCounts, allTransactions);
    }

    function createEtherscanApi() {
        return new EtherscanApi(document.getElementById('api-key').value);
    }


    function getInputAddresses() {
        const inputAddresses = document.getElementById('singleAddress').value;
        return inputAddresses.split(',').map(a => a.trim());
    }

async function fetchAllTransactions(addresses, addressTransactionCounts, etherscanApi) {
    const transactionEndpoints = [
        { singleTransactionType: 'txlist', transactionFetchFunction: fetchSingleAddressTransactions },
        { singleTransactionType: 'txlistinternal', transactionFetchFunction: fetchSingleAddressTransactions },
        { singleTransactionType: 'tokentx', transactionFetchFunction: fetchSingleAddressTransactions },
        { singleTransactionType: 'tokennfttx', transactionFetchFunction: fetchSingleAddressTransactions },
        { singleTransactionType: 'token1155tx', transactionFetchFunction: fetchSingleAddressTransactions },
    ];

    const allTransactions = [];

    for (const transactionEndpoint of transactionEndpoints) {
        const { allTransactions: transactions, addressTransactionCounts: transactionCounts } = await fetchTransactionsForAllAddresses(transactionEndpoint.transactionFetchFunction, addresses, transactionEndpoint.singleTransactionType, addressTransactionCounts, etherscanApi);

        allTransactions.push(...transactions);
        await new Promise(resolve => setTimeout(resolve, 1000));
    }

    return allTransactions;
}

function displayAllTransactions(addressTransactionCounts, allTransactions) {
    displayTransactionSummary(addressTransactionCounts, allTransactions.length);
    displayTransactionTable(allTransactions);
}

async function fetchTransactionsForAllAddresses(transactionFetchFunction, addresses, singleTransactionType, addressTransactionCounts, etherscanApi) {
  const allTransactions = [];

  for (const singleAddress of addresses) {
    const transactions = await fetchTransactionsForAddress(transactionFetchFunction, singleAddress, singleTransactionType, etherscanApi);
    allTransactions.push(...transactions);
    addressTransactionCounts[singleAddress] += transactions.length;
  }

  return {
    allTransactions,
    addressTransactionCounts
  };
}

async function fetchTransactionsForAddress(transactionFetchFunction, singleAddress, singleTransactionType, etherscanApi) {
  const records = await transactionFetchFunction(singleAddress, singleTransactionType, etherscanApi);
  const type = singleTransactionType === 'txlist' ? 'normal' : singleTransactionType === 'txlistinternal' ? 'internal' : singleTransactionType === 'tokentx' ? 'erc20' : singleTransactionType === 'tokennfttx' ? 'erc721' : 'erc1155';
  const transactionMapper = tx => ({
    ...tx,
    type
  });

  return records.map(transactionMapper);
}


async function fetchSingleAddressTransactions(singleAddress, singleTransactionType, etherscanApi) {
  try {
    const records = await etherscanApi.fetchTransactionDataWithPagination({
      singleTransactionType,
      singleAddress
    });

    return records;
  } catch (error) {
    console.error("Error fetching transactions and transfers:", error);
    return [];
  }
}




function displayTransactionSummary(addressTransactionCounts, totalCount) {
	const summaryDiv = document.getElementById('summary');
	const summaryItems = generateSummaryItems(addressTransactionCounts);
	summaryDiv.innerHTML = `Total entries found: ${totalCount}<br>${summaryItems}`;
}

function generateSummaryItems(addressTransactionCounts) {
	return Object.entries(addressTransactionCounts)
		.map(([singleAddress, count]) => `Entries found for ${singleAddress}: ${count}<br>`)
		.join('');
}

function displayTransactionTable(transactions) {
	const resultsDiv = document.getElementById('results');
	resultsDiv.innerHTML = '';

	transactions.sort((a, b) => parseInt(a.timeStamp) - parseInt(b.timeStamp));

	const table = createTransactionTable(transactions);
	resultsDiv.appendChild(table);
}

function createTransactionTable(transactions) {
	const table = document.createElement('table');
	const headers = createTransactionTableHeaders();
	const rows = createTransactionTableRows(transactions);

	table.innerHTML = headers + rows;
	return table;
}

function createTransactionTableHeaders() {
	return `
		<tr>
		    <th>Type</th>
		    <th>Timestamp</th>
		    <th>TX Hash</th>
		    <th>Function</th>
		    <th>Value</th>
		    <th>Token Symbol</th>
		    <th>From</th>
		    <th>To</th>
		    <th>Contract Address</th>
		    <th>TokenID</th>
		    <th>TX Fee (ETH)</th>
		    <th>Token Name</th>
		    <th>Gas Price (Gwei)</th>
		    <th>TX Failed</th>
		</tr>
	    `;
}


function createTransactionTableRows(transactions) {
	return transactions.map(tx => createEachTransactionTableRow(tx)).join('');
}

function createEachTransactionTableRow(tx) {
	const value = getTransactionValue(tx);
	const tokenSymbol = getTransactionTokenSymbol(tx);
	const transactionFee = ((parseInt(tx.gasPrice) * parseInt(tx.gasUsed)) / 1e18).toFixed(6);
	const functionName = tx.functionName ? tx.functionName.split('(')[0] : 'N/A';

	return `
		<tr>
		    <td>${tx.type}</td>
		    <td>${new Date(tx.timeStamp * 1000).toLocaleString()}</td>
		    <td>${tx.hash}</td>
		    <td>${functionName}</td>
		    <td>${value}</td>
		    <td>${tokenSymbol}</td>
		    <td>${tx.from}</td>
		    <td>${tx.to}</td>
		    <td>${tx.contractAddress}</td>
		    <td>${tx.tokenID ?? 'N/A'}</td>
		    <td>${transactionFee}</td>
		    <td>${tx.tokenName || 'N/A'}</td>
		    <td>${(parseInt(tx.gasPrice) / 1e9).toFixed(6)}</td>
		    <td>${tx.isError === '1' ? 'Yes' : 'No'}</td>
		</tr>
	    `;
}



function getTransactionValue(tx) {
	if (['normal', 'internal', 'erc20'].includes(tx.type)) {
		return getEthOrErc20TransactionValue(tx);
	} else if (tx.type === 'erc721') {
		return 1;
	} else if (tx.type === 'erc1155') {
		return tx.tokenValue;
	}
}

function getEthOrErc20TransactionValue(tx) {
	const decimal = tx.type === 'erc20' && tx.tokenDecimal !== 'N/A' ? tx.tokenDecimal : 18;
	return (parseInt(tx.value) / Math.pow(10, decimal)).toFixed(6);
}

function getTransactionTokenSymbol(tx) {
	if (['internal', 'normal'].includes(tx.type)) {
		return 'ETH';
	} else if (tx.type === 'erc20') {
		return tx.tokenSymbol || 'N/A';
	} else if (['erc721', 'erc1155'].includes(tx.type)) {
		return `${tx.tokenSymbol}-${tx.tokenID}`;
	}
} 
</script>
</html>
