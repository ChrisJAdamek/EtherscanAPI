<!DOCTYPE html>
<html>
  <head>
    <title>Etherscan API - Transaction List</title>
    <style>
      body {
        font-family: Arial, sans-serif;
      }
      #results {
        margin-top: 20px;
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;
      }
      th {
        background-color: #f2f2f2;
        font-weight: bold;
      }
    </style>
  </head>
<body>
  <h1>Etherscan API</h1>
  <label for="api-key">Enter your Etherscan API Key:</label>
  <input type="text" id="api-key" placeholder="Your API Key">
  <br>
  <label for="singleAddress">Enter Ethereum addresses (comma-separated):</label>
  <input type="text" id="singleAddress" placeholder="0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae, 0x742d35Cc6634C0532925a3b844Bc454e4438f44e">
  <button id="fetchAndDisplayTransactions">Fetch and Display Transactions</button>

  <div id="summary"></div>
  <div id="results"></div>
</body>

<script>

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('fetchAndDisplayTransactions').addEventListener('click', fetchAndDisplayTransactions);
});


class EtherscanApi {
    constructor(apiKey) {
        this.apiKey = apiKey;
        this.baseUrl = "https://api.etherscan.io/api";
        this.apiCallCount = 0;
        this.startTime = Date.now();
    }

    async fetchTransactionDataWithPagination(args) {
        const data = await this.fetchTransactionData(args);
        if (data.length === 10000) {
            console.log("Fetching next page...");
            const nextPageData = await this.fetchTransactionDataWithPagination({
                ...args,
                page: args.page + 1,
            });
            return data.concat(nextPageData);
        }
        return data;
    }


    async fetchTransactionData({
        singleTransactionType,
        buildURLFunction,
        singleAddress,
        page = 1,
        retries = 20,
        delay = 500
    }) {
        this.apiCallCount++;
        const url = buildURLFunction(singleAddress, page);
        try {
            const response = await fetch(url);
            const data = await response.json();

            if (data.status === "0" && data.message === "NOTOK" && data.result === "Max rate limit reached" && retries > 0) {
                console.warn("Max rate limit reached. Retrying...");
                await new Promise(resolve => setTimeout(resolve, delay));
                return await this.fetchTransactionData({
                    singleTransactionType: singleTransactionType,
                    buildURLFunction,
                    singleAddress,
                    page,
                    retries: retries - 1,
                    delay: delay * 2
                });
            }
            if (this.apiCallCount % 1 === 0) { // Log every 10 calls or choose your preferred frequency
                const elapsedTime = ((Date.now() - this.startTime) / 1000).toFixed(2);
                console.log(`API call count: ${this.apiCallCount}, Elapsed time: ${elapsedTime} seconds`);
            }

            return data.result;
        } catch (error) {
            console.error("Error fetching data:", error);
            return [];
        }
    }



    buildTxlistURL(singleAddress, page) {
        return this.buildBaseURL('txlist', singleAddress, page);
    }

    buildTxlistInternalURL(singleAddress, page) {
        return this.buildBaseURL('txlistinternal', singleAddress, page);
    }

    buildTokenTxURL(singleAddress, page) {
        return this.buildBaseURL('tokentx', singleAddress, page);
    }

    buildTokenNftTxURL(singleAddress, page) {
        return this.buildBaseURL('tokennfttx', singleAddress, page);
    }

    buildToken1155TxURL(singleAddress, page) {
        return this.buildBaseURL('token1155tx', singleAddress, page);
    }

    buildBaseURL(singleTransactionType, singleAddress, page) {
        return `${this.baseUrl}?module=account&action=${singleTransactionType}&address=${singleAddress}&startblock=0&endblock=latest&page=${page}&offset=10000&sort=asc&apikey=${this.apiKey}`;
    }


}

async function fetchAndDisplayTransactions() {
    const etherscanApi = createEtherscanApi();
    const addresses = getInputAddresses();

    const addressTransactionCounts = initializeAddressTransactionCounts(addresses);
    const allTransactions = await fetchAllTransactions(addresses, addressTransactionCounts, etherscanApi);
    displayTransactions(addressTransactionCounts, allTransactions);
}

function createEtherscanApi() {
    return new EtherscanApi(document.getElementById('api-key').value);
}

function getInputAddresses() {
    const inputAddresses = document.getElementById('singleAddress').value;
    return inputAddresses.split(',').map(a => a.trim());
}



function initializeAddressTransactionCounts(addresses) {
    const addressTransactionCounts = {};
    addresses.forEach(singleAddress => addressTransactionCounts[singleAddress] = 0);
    return addressTransactionCounts;
}


async function promiseAllWithConcurrency(promises, concurrency) {
    const results = [];
    const executing = [];

    for (const promise of promises) {
        const p = promise();
        results.push(p);

        if (concurrency <= promises.length) {
            const e = p.then(() => executing.splice(executing.indexOf(e), 1));
            executing.push(e);
            if (executing.length >= concurrency) {
                await Promise.race(executing);
            }
        }
    }

    return Promise.all(results);
}

function calculateConcurrency(addressesCount, transactionTypesCount, concurrencyPercentage = 0.1) {
    const totalTasks = addressesCount * transactionTypesCount;
    const concurrency = Math.ceil(totalTasks * concurrencyPercentage);

    // Ensure concurrency is at least 1 to prevent blocking the execution
    return Math.max(1, concurrency);
}


async function fetchAllTransactions(addresses, addressTransactionCounts, etherscanApi) {
    const transactionEndpoints = [{
            singleTransactionType: 'txlist',
            buildURLFunction: etherscanApi.buildTxlistURL.bind(etherscanApi),
            transactionFetchFunction: fetchSingleAddressTransactions
        },
        {
            singleTransactionType: 'txlistinternal',
            buildURLFunction: etherscanApi.buildTxlistInternalURL.bind(etherscanApi),
            transactionFetchFunction: fetchSingleAddressTransactions
        },
        {
            singleTransactionType: 'tokentx',
            buildURLFunction: etherscanApi.buildTokenTxURL.bind(etherscanApi),
            transactionFetchFunction: fetchSingleAddressTransactions
        },
        {
            singleTransactionType: 'tokennfttx',
            buildURLFunction: etherscanApi.buildTokenNftTxURL.bind(etherscanApi),
            transactionFetchFunction: fetchSingleAddressTransactions
        },
        {
            singleTransactionType: 'token1155tx',
            buildURLFunction: etherscanApi.buildToken1155TxURL.bind(etherscanApi),
            transactionFetchFunction: fetchSingleAddressTransactions
        },
    ];


    const allTransactions = [];

    // Calculate the dynamic concurrency
    const addressesCount = addresses.length;
    const transactionTypesCount = transactionEndpoints.length;
    const concurrency = calculateConcurrency(addressesCount, transactionTypesCount);

    await promiseAllWithConcurrency(transactionEndpoints.map(transactionEndpoint => async () => {
        const {
            transactions,
            transactionCounts
        } = await fetchTransactionsForEndpoint(transactionEndpoint, addresses, addressTransactionCounts, etherscanApi);
        allTransactions.push(...transactions);
    }), concurrency);

    return allTransactions;
}



async function fetchTransactionsForEndpoint(transactionEndpoint, addresses, addressTransactionCounts, etherscanApi) {
    const {
        allTransactions: transactions,
        addressTransactionCounts: transactionCounts
    } = await fetchTransactionsForAllAddresses(transactionEndpoint.transactionFetchFunction, addresses, transactionEndpoint.singleTransactionType, addressTransactionCounts, etherscanApi, transactionEndpoint.buildURLFunction);

    return {
        transactions,
        transactionCounts
    };
}




async function fetchTransactionsForAllAddresses(transactionFetchFunction, addresses, singleTransactionType, addressTransactionCounts, etherscanApi, buildURLFunction) {
    const allTransactions = [];

    for (const singleAddress of addresses) {
        const transactions = await fetchTransactionsForAddress(transactionFetchFunction, singleAddress, singleTransactionType, etherscanApi, buildURLFunction);
        allTransactions.push(...transactions);
        addressTransactionCounts[singleAddress] += transactions.length;
    }

    return {
        allTransactions,
        addressTransactionCounts
    };
}



async function fetchTransactionsForAddress(transactionFetchFunction, singleAddress, singleTransactionType, etherscanApi, buildURLFunction) {
    const records = await transactionFetchFunction(singleAddress, singleTransactionType, etherscanApi, buildURLFunction);
    const type = singleTransactionType === 'txlist' ? 'normal' : singleTransactionType === 'txlistinternal' ? 'internal' : singleTransactionType === 'tokentx' ? 'erc20' : singleTransactionType === 'tokennfttx' ? 'erc721' : 'erc1155';
    const transactionMapper = tx => ({
        ...tx,
        type
    });

    return records.map(transactionMapper);
}



async function fetchSingleAddressTransactions(singleAddress, singleTransactionType, etherscanApi, buildURLFunction) {
    try {
        const records = await etherscanApi.fetchTransactionDataWithPagination({
            buildURLFunction,
            singleAddress
        });

        return records;
    } catch (error) {
        console.error("Error fetching transactions and transfers:", error);
        return [];
    }
}


function displayTransactions(addressTransactionCounts, allTransactions) {
    displayTransactionSummary(addressTransactionCounts, allTransactions.length);
    displayTransactionTable(allTransactions);
}

function displayTransactionSummary(addressTransactionCounts, totalCount) {
    const summaryDiv = document.getElementById('summary');
    const summaryItems = generateSummaryItems(addressTransactionCounts);
    summaryDiv.innerHTML = `Total entries found: ${totalCount}<br>${summaryItems}`;
}

function generateSummaryItems(addressTransactionCounts) {
    return Object.entries(addressTransactionCounts)
        .map(([singleAddress, count]) => `Entries found for ${singleAddress}: ${count}<br>`)
        .join('');
}

function displayTransactionTable(transactions) {
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '';

    transactions.sort((a, b) => parseInt(a.timeStamp) - parseInt(b.timeStamp));

    const table = createTransactionTable(transactions);
    resultsDiv.appendChild(table);
}

function createTransactionTable(transactions) {
    const table = document.createElement('table');
    const header = createTransactionTableHeader();
    const body = createTransactionTableBody(transactions);

    table.innerHTML = header + body;
    return table;
}




function createTransactionTableHeader() {
    return `
    <tr>
      <th>Type</th>
      <th>Timestamp</th>
      <th>TX Hash</th>
      <th>Function</th>
      <th>Value</th>
      <th>Token Symbol</th>
      <th>From</th>
      <th>To</th>
      <th>Contract Address</th>
      <th>TokenID</th>
      <th>TX Fee (ETH)</th>
      <th>Token Name</th>
      <th>Gas Price (Gwei)</th>
      <th>TX Failed</th>
    </tr>
  `;
}

function createTransactionTableBody(transactions) {
    return transactions.map(tx => createEachTransactionTableRow(tx)).join('');
}

function createEachTransactionTableRow(tx) {
    const value = getTransactionValue(tx);
    const tokenSymbol = getTransactionTokenSymbol(tx);
    const transactionFee = ((parseInt(tx.gasPrice) * parseInt(tx.gasUsed)) / 1e18).toFixed(6);
    const functionName = tx.functionName ? tx.functionName.split('(')[0] : 'N/A';

    return `
		<tr>
		    <td>${tx.type}</td>
		    <td>${new Date(tx.timeStamp * 1000).toLocaleString()}</td>
		    <td>${tx.hash}</td>
		    <td>${functionName}</td>
		    <td>${value}</td>
		    <td>${tokenSymbol}</td>
		    <td>${tx.from}</td>
		    <td>${tx.to}</td>
		    <td>${tx.contractAddress}</td>
		    <td>${tx.tokenID ?? 'N/A'}</td>
		    <td>${transactionFee}</td>
		    <td>${tx.tokenName || 'N/A'}</td>
		    <td>${(parseInt(tx.gasPrice) / 1e9).toFixed(6)}</td>
		    <td>${tx.isError === '1' ? 'Yes' : 'No'}</td>
		</tr>
	    `;
}

function getTransactionValue(tx) {
    if (['normal', 'internal', 'erc20'].includes(tx.type)) {
        return getEthOrErc20TransactionValue(tx);
    } else if (tx.type === 'erc721') {
        return 1;
    } else if (tx.type === 'erc1155') {
        return tx.tokenValue;
    }
}

function getEthOrErc20TransactionValue(tx) {
    const decimal = tx.type === 'erc20' && tx.tokenDecimal !== 'N/A' ? tx.tokenDecimal : 18;
    return (parseInt(tx.value) / Math.pow(10, decimal)).toFixed(6);
}

function getTransactionTokenSymbol(tx) {
    if (['internal', 'normal'].includes(tx.type)) {
        return 'ETH';
    } else if (tx.type === 'erc20') {
        return tx.tokenSymbol || 'N/A';
    } else if (['erc721', 'erc1155'].includes(tx.type)) {
        return `${tx.tokenSymbol}-${tx.tokenID}`;
    }
}
</script>
</html>
