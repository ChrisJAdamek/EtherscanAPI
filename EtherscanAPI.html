<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explorer Aggregator</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link href="https://fonts.googleapis.com/css?family=Poppins:400,500,600,700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Poppins', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f8f9fa;
        }

        .container {
            max-width: 3000px;
            margin: 0 auto;
            padding: 30px;
        }

        header {
            text-align: center;
        }

        h1 {
            font-size: 36px;
            font-weight: 700;
            color: #343a40;
        }

        hr {
            border: none;
            border-top: 1px solid #dee2e6;
            margin: 20px 0;
        }

        form {
            padding: 20px;
            background-color: #ffffff;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            grid-gap: 20px;
            justify-content: center;
            align-items: center;
        }

        fieldset {
            border: none;
            padding: 0;
            margin: 0;
        }

        legend {
            font-size: 18px;
            font-weight: 500;
            color: #343a40;
            margin-bottom: 10px;
        }

        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            color: #495057;
            margin-bottom: 5px;
        }

        input[type="text"],
        textarea {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            font-family: 'Poppins', sans-serif;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background-color: #ffffff;
            color: #495057;
            outline: none;
            transition: border-color 0.15s ease-in-out;
        }

        input[type="text"]:focus,
        textarea:focus {
            border-color: #80bdff;
            box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
        }

        textarea {
            resize: vertical;
        }

        button {
            display: inline-block;
            padding: 6px 12px;
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            background-color: #007bff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.15s ease-in-out;
        }

        button:hover {
            background-color: #0056b3;
        }

        #results {
            margin-top: 20px;
        }

        table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            background-color: #ffffff;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        th,
        td {

            border: 1px solid #dee2e6;
            padding: 8px;
            text-align: left;
            font-size: 14px;
            color: #495057;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
        }

        tr:nth-child(even) {
            background-color: #f2f3f4;
        }

        tr:hover {
            background-color: #e9ecef;
        }

        #summary {
            margin-top: 20px;
            font-size: 16px;
            font-weight: 500;
            color: #343a40;
        }
        

    </style>
    <div id="error-message" style="display: none; color: red; font-weight: bold; margin-bottom: 10px;"></div>
</head>

<body>
    <div class="container">
        <header>
            <h1>Explorer Aggregator</h1>
            <hr>
        </header>
        <section>
            <form>
                <div class="grid-container">
                    <fieldset>
                        <legend>API Keys</legend>
                        <div>
                            <label for="etherscan-api-key">Etherscan API Key:</label>
                            <input type="text" id="etherscan-api-key" placeholder="Your Etherscan API Key" required>
                        </div>
                        <div>
                            <label for="arbiscan-api-key">Arbiscan API Key:</label>
                            <input type="text" id="arbiscan-api-key" placeholder="Your Arbiscan API Key" required>
                        </div>
                    </fieldset>
                    <fieldset>
                        <legend>Addresses</legend>
                        <div>
                            <label for="singleAddress">Addresses (comma-separated):</label>
                            <textarea id="singleAddress" rows="4" placeholder="0xde0b295669a9fd93d5f28d9ec85e40f4cb697bae, 0x742d35Cc6634C0532925a3b844Bc454e4438f44e" required></textarea>
                        </div>
                    </fieldset>
                    <div>
                        <label for="retrieveAndDisplayAllTransactions">Fetch and Display Transactions:</label>
                        <button id="retrieveAndDisplayAllTransactions" type="button">Fetch and Display Transactions</button>
                    </div>
                </div>
            </form>
            <div id="summary"></div>
            <hr>
            <div id="results"></div>
        </section>
    </div>
</body>

<script type="module">

let startTime;
document.addEventListener('DOMContentLoaded', () => {
    console.log(`[DEBUG] Document ready, setting up event listeners.`);
    setupEventListeners();
});


class BlockchainAPI {
  constructor(t, n) {
    this.apiKey = t;
    this.baseUrl = n;
    this.apiCallCount = 0;
    this.startTime = Date.now();
  }

async sleep(delay) {
  return new Promise(resolve => setTimeout(resolve, delay));
}

async fetchTransactionsWithDelay(delay, args) {
  await this.sleep(delay);
  return this.fetchTransactions(args);
}

  async fetchTransactions({ singleTransactionType, buildURLFunction, singleAddress, page = 1, retries = 20, delay = 500, error = null }) {
    this.apiCallCount++;
    let l = buildURLFunction(singleAddress, page);

    // Sleep to manage rate limits
    await this.sleep(this.apiCallCount * 200); // 334 ms per call

    try {
      let o = await fetch(l),
        c = await o.json();
      if ("0" === c.status && "NOTOK" === c.message && "Max rate limit reached" === c.result || 429 === o.status) {
        if (!(retries > 0)) return { failed: !0, data: [] };
        {
          await new Promise(t => setTimeout(t, delay));
          let u = await this.fetchTransactions({ singleTransactionType, buildURLFunction, singleAddress, page, retries: retries - 1, delay: 2 * delay, error });
          return u;
        }
      }
      return this.apiCallCount % 1 == 0 && ((Date.now() - this.startTime) / 1e3).toFixed(2), Array.isArray(c.result) ? { failed: !1, data: c.result } : { failed: !1, data: [] };
    } catch (d) {
      return await this.fetchTransactions({ singleTransactionType, buildURLFunction, singleAddress, page, retries: retries - 1, delay: 2 * delay, error: d });
    } finally { }
  }

  totalElapsedTime() {
    return ((Date.now() - this.startTime) / 1000).toFixed(2);
  }
  
  
     async initiateTransactionDataAssembly(args) {
        console.log(`[DEBUG] [${totalElapsedTime()}s] initiateTransactionDataAssembly called with args:`, args);
        return this.concatenateTransactionDataWithPagination(args);
    }
    async concatenateTransactionDataWithPagination(args) {
        console.log(`[DEBUG] [${totalElapsedTime()}s] concatenateTransactionDataWithPagination called with args:`, args);
        const data = await this.fetchTransactions(args);
        if (data.length === 10000) {
            console.log(`[DEBUG] [${totalElapsedTime()}s] Fetching next page...`);
            const nextPageData = await this.concatenateTransactionDataWithPagination({
                ...args,
                page: args.page + 1,
            });
            console.log(`[DEBUG] [${totalElapsedTime()}s] Concatenating data from next page`);
            return data.concat(nextPageData);
        }
      
        return data;
    }






    buildTxlistURL(singleAddress, page) {
        return this.buildBaseURL('txlist', singleAddress, page);
    }
    buildTxlistInternalURL(singleAddress, page) {
        return this.buildBaseURL('txlistinternal', singleAddress, page);
    }
    buildTokenTxURL(singleAddress, page) {
        return this.buildBaseURL('tokentx', singleAddress, page);
    }
    buildTokenNftTxURL(singleAddress, page) {
        return this.buildBaseURL('tokennfttx', singleAddress, page);
    }
    buildToken1155TxURL(singleAddress, page) {
        return this.buildBaseURL('token1155tx', singleAddress, page);
    }
    buildBaseURL(singleTransactionType, singleAddress, page) {
        return `${this.baseUrl}?module=account&action=${singleTransactionType}&address=${singleAddress}&startblock=0&endblock=latest&page=${page}&offset=10000&sort=asc&apikey=${this.apiKey}`;
    }
}

    









async function retrieveAndDisplayAllTransactions() {
    startTime = new Date();
    console.log(`[DEBUG] [${totalElapsedTime()}s] retrieveAndDisplayAllTransactions called`);
    const [etherscanApi, arbiscanApi] = createBlockchainAPIs();
    const addresses = getInputAddresses();
    console.log(`[DEBUG] [${totalElapsedTime()}s] Addresses obtained:`, addresses);
    const addressTransactionCounts = initializeAddressTransactionCounts(addresses);
    let hasFailedTransactions = false;
    console.log(`[DEBUG] [${totalElapsedTime()}s] Initialized address transaction counts:`, addressTransactionCounts);
    const allTransactions = await getAllTransactions(addresses, addressTransactionCounts, [etherscanApi, arbiscanApi]);
    console.log(`[DEBUG] [${totalElapsedTime()}s] All transactions fetched, displaying transactions...`);
    const errorMessageElement = document.getElementById("error-message");
    if (hasFailedTransactions) {
        errorMessageElement.style.display = "block";
        errorMessageElement.textContent = "Error: Some transactions could not be fetched.";
    } else {
        errorMessageElement.style.display = "none";
    }
    displayTransactions(addressTransactionCounts, allTransactions);
}




async function getAllTransactions(addresses, addressTransactionCounts, apis) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] [getAllTransactions] called with addresses:`, addresses, `addressTransactionCounts:`, addressTransactionCounts, `apis:`, apis);
    
    const transactionEndpoints = [
        {
            singleTransactionType: 'txlist',
            buildURLFunction: api => api.buildTxlistURL.bind(api),
            transactionFetchFunction: getPaginatedAddressTransactions
        },
        {
            singleTransactionType: 'txlistinternal',
            buildURLFunction: api => api.buildTxlistInternalURL.bind(api),
            transactionFetchFunction: getPaginatedAddressTransactions
        },
        {
            singleTransactionType: 'tokentx',
            buildURLFunction: api => api.buildTokenTxURL.bind(api),
            transactionFetchFunction: getPaginatedAddressTransactions
        },
        {
            singleTransactionType: 'tokennfttx',
            buildURLFunction: api => api.buildTokenNftTxURL.bind(api),
            transactionFetchFunction: getPaginatedAddressTransactions
        },
        {
            singleTransactionType: 'token1155tx',
            buildURLFunction: api => api.buildToken1155TxURL.bind(api),
            transactionFetchFunction: getPaginatedAddressTransactions
        }
    ];

    const uniqueCombinations = generateUniqueCombinations(apis, transactionEndpoints);

    // Create an array of promises for each unique combination
    const fetchTransactionPromises = uniqueCombinations.map(async ({ api, transactionEndpoint }) => {
        console.log(`[DEBUG] [${totalElapsedTime()}s] Generating uniqueCombinations: ${transactionEndpoint.singleTransactionType}`);

        const { transactions, transactionCounts } = await getTransactionsForEndpoint(transactionEndpoint, addresses, addressTransactionCounts, api, transactionEndpoint.buildURLFunction);

        return transactions;
    });

    // Wait for all promises to resolve and concatenate the results
    const allTransactions = (await Promise.all(fetchTransactionPromises)).flat();
    console.log(`[DEBUG] [${totalElapsedTime()}s] Await all promises to resolve and concatenate`);
    return allTransactions;
}



function generateUniqueCombinations(apis, transactionEndpoints) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] [generateUniqueCombinations] called with apis:`, apis, `transactionEndpoints:`, transactionEndpoints);
    const uniqueCombinations = [];
    for (const [apiIndex, api] of apis.entries()) {
        console.log(`[DEBUG] [${totalElapsedTime()}s] [generateUniqueCombinations] Processing: ${api.baseUrl}`);
        for (const [transactionEndpointIndex, transactionEndpoint] of transactionEndpoints.entries()) {
            console.log(`[DEBUG] [${totalElapsedTime()}s] [generateUniqueCombinations] Processing: ${transactionEndpoint.singleTransactionType} for ${api.baseUrl}`);
            uniqueCombinations.push({
                api,
                transactionEndpoint
            });
            console.log(`[DEBUG] [${totalElapsedTime()}s] [generateUniqueCombinations] Added combination:`, {
                api,
                transactionEndpoint
            });
        }
    }
    console.log(`[DEBUG] [${totalElapsedTime()}s] [generateUniqueCombinations] Generated uniqueCombinations:`, uniqueCombinations);
    return uniqueCombinations;
}
async function getTransactionsForEndpoint(transactionEndpoint, addresses, addressTransactionCounts, api, buildURLFunction) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] [getTransactionsForEndpoint] called with transactionEndpoint:`, api.baseURL, transactionEndpoint.singleTransactionType, "addresses:", addresses);
    const key = transactionEndpoint.singleTransactionType;
    console.log(`[DEBUG] [${totalElapsedTime()}s] [getTransactionsForEndpoint] Calling getAllAddressTransactions with transactionFetchFunction:`, transactionEndpoint.transactionFetchFunction);
    const {
        allTransactions: transactions,
        addressTransactionCounts: transactionCounts
    } = await getAllAddressTransactions(transactionEndpoint.transactionFetchFunction, addresses, transactionEndpoint.singleTransactionType, addressTransactionCounts, api, buildURLFunction);
    console.log(`[DEBUG] [${totalElapsedTime()}s] [getTransactionsForEndpoint] Returning transactions and transactionCounts`);
    return {
        transactions,
        transactionCounts
    };
}
async function getAllAddressTransactions(transactionFetchFunction, addresses, singleTransactionType, addressTransactionCounts, api, buildURLFunction) {
    console.log('Fetching transactions for all addresses:, addresses');
    const allTransactions = [];
    for (const singleAddress of addresses) {
        const transactions = await getSingleAddressTransactions(transactionFetchFunction, singleAddress, singleTransactionType, api, buildURLFunction);
        allTransactions.push(...transactions);
        addressTransactionCounts[singleAddress] += transactions.length;
    }
    return {
        allTransactions,
        addressTransactionCounts
    };
}
async function getSingleAddressTransactions(transactionFetchFunction, singleAddress, singleTransactionType, api, buildURLFunction) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] Fetching transactions for address:`, singleAddress, 'for transaction type:', singleTransactionType);
    console.log(`[DEBUG] [${totalElapsedTime()}s] Transaction fetch function:`, transactionFetchFunction);
    console.log(`[DEBUG] [${totalElapsedTime()}s] API:`, api);
    const result = await transactionFetchFunction(singleAddress, singleTransactionType, api, buildURLFunction);
    const records = result.data;
    if (result.failed) {
        hasFailedTransactions = true;
        console.error(`[DEBUG] [${totalElapsedTime()}s] Fetching transactions failed for address: ${singleAddress} and transaction type: ${singleTransactionType}`);
    }
    const type = singleTransactionType === 'txlist' ? 'normal' : singleTransactionType === 'txlistinternal' ? 'internal' : singleTransactionType === 'tokentx' ? 'erc20' : singleTransactionType === 'tokennfttx' ? 'erc721' : 'erc1155';
    const transactionMapper = tx => ({
        ...tx,
        type
    });
    return records.map(transactionMapper);
}
async function getPaginatedAddressTransactions(singleAddress, singleTransactionType, api, buildURLFunction) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] Fetching single address transactions for address ${singleAddress} and transaction type ${singleTransactionType} using API ${api}`);
    try {
        const records = await api.concatenateTransactionDataWithPagination({
            singleTransactionType: singleTransactionType,
            buildURLFunction: buildURLFunction(api),
            singleAddress,
            page: 1,
            retries: 20,
            delay: 500,
            api: api
        });
        return records;
    } catch (error) {
        console.error(`[ERROR] [${totalElapsedTime()}s] Error fetching transactions for singleAddress ${singleAddress} and singleTransactionType ${singleTransactionType}:`, error);
        return [];
    }
}





class EtherscanAPI extends BlockchainAPI {
    constructor(apiKey) {
        super(apiKey, "https://api.etherscan.io/api");
        console.log('EtherscanAPI constructor called with apiKey:', apiKey);
    }
}
class ArbiscanAPI extends BlockchainAPI {
    constructor(apiKey) {
        super(apiKey, "https://api.arbiscan.io/api");
        console.log('ArbiscanAPI constructor called with apiKey:', apiKey);
    }
}

function initializeAddressTransactionCounts(addresses) {
    console.log('Initializing address transaction counts for addresses:', addresses);
    const addressTransactionCounts = {};
    addresses.forEach(singleAddress => addressTransactionCounts[singleAddress] = 0);
    return addressTransactionCounts;
}

function getInputAddresses() {
    console.log(`[DEBUG] [${totalElapsedTime()}s] getInputAddresses called`);
    const inputAddresses = document.getElementById('singleAddress').value;
    const addressArray = inputAddresses.split(',').map(a => a.trim());
    console.log(`[DEBUG] [${totalElapsedTime()}s] Parsed addresses:`, addressArray);
    return addressArray;
}

function totalElapsedTime() {
    const currentTime = new Date();
    const elapsedTime = currentTime - startTime;
    // Convert milliseconds to seconds and round to two decimal places
    return (elapsedTime / 1000).toFixed(2);
}

function setupEventListeners() {
    console.log(`[DEBUG] Setting up event listeners`);
    document.getElementById('retrieveAndDisplayAllTransactions').addEventListener('click', retrieveAndDisplayAllTransactions);
    console.log(`[DEBUG] Event listener for submitButton set up`);
}

function createBlockchainAPIs() {
    console.log('createBlockchainAPIs called');
    const etherscanApiKey = document.getElementById('etherscan-api-key').value;
    const arbiscanApiKey = document.getElementById('arbiscan-api-key').value;
    console.log("Etherscan API Key found:", etherscanApiKey);
    console.log("Arbiscan API Key found:", arbiscanApiKey);
    const apis = [];
    if (etherscanApiKey) {
        const etherscanApi = new EtherscanAPI(etherscanApiKey);
        if (etherscanApi) {
            apis.push(etherscanApi);
        } else {
            console.error("Etherscan API object is undefined");
        }
    }
    if (arbiscanApiKey) {
        const arbiscanApi = new ArbiscanAPI(arbiscanApiKey);
        if (arbiscanApi) {
            apis.push(arbiscanApi);
        } else {
            console.error("Arbiscan API object is undefined");
        }
    }
    console.log("APIs:", apis);
    if (apis.length === 0) {
        alert('Please provide at least one valid API key (Etherscan or Arbiscan).');
        throw new Error('Valid API keys missing');
    }
    return apis;
}






function displayTransactions(addressTransactionCounts, allTransactions) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] [displayTransactions] Displaying transactions with addressTransactionCounts:`, addressTransactionCounts, `allTransactions:`, allTransactions);
    displayTransactionSummary(addressTransactionCounts, allTransactions.length);
    displayTransactionTable(allTransactions);
}

function displayTransactionSummary(addressTransactionCounts, totalCount) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] [displayTransactionSummary] Displaying transaction summary with totalCount: ${totalCount} and addressTransactionCounts:`, addressTransactionCounts);
    const summaryDiv = document.getElementById('summary');
    const summaryItems = generateSummaryItems(addressTransactionCounts);
    summaryDiv.innerHTML = `Total entries found: ${totalCount}<br>${summaryItems}`;
}

function generateSummaryItems(addressTransactionCounts) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] [generateSummaryItems] Generating summary items with addressTransactionCounts:`, addressTransactionCounts);
    const summaryItems = Object.entries(addressTransactionCounts).map(([singleAddress, count]) => `Entries found for ${singleAddress}: ${count}<br>`).join('');
    console.log(`[DEBUG] [${totalElapsedTime()}s] [generateSummaryItems] Generated summary items:`);
    return summaryItems;
}

function displayTransactionTable(transactions) {
    console.log(`[DEBUG] [${totalElapsedTime()}s] [displayTransactionTable] Displaying transaction table with transactions:`);
    const resultsDiv = document.getElementById('results');
    resultsDiv.innerHTML = '';
    transactions.sort((a, b) => parseInt(a.timeStamp) - parseInt(b.timeStamp));
    console.log(`[DEBUG] [${totalElapsedTime()}s] [displayTransactionTable] Sorted transactions:`);
    const table = createTransactionTable(transactions);
    resultsDiv.appendChild(table);
    console.log(`[DEBUG] [${totalElapsedTime()}s] [displayTransactionTable] Transaction table appended to resultsDiv`);
}

function createTransactionTable(transactions) {
    const table = document.createElement('table');
    const header = createTransactionTableHeader();
    const body = createTransactionTableBody(transactions);
    table.innerHTML = header + body;
    return table;
}

function createTransactionTableHeader() {
    return `
    <tr>
      <th style="width:3%">Type</th>
      <th style="width:10%">Timestamp</th>
      <th style="width:7%">TX Hash</th>
      <th style="width:10%">Function</th>
      <th style="width:5%">Value</th>
      <th style="width:7%">Token Symbol</th>
      <th style="width:15%">From</th>
      <th style="width:15%">To</th>
      <th style="width:15%">Contract Address</th>
      <!--th style="width:5%">TokenID</th-->
      <th style="width:5%">TX Fee (ETH)</th>
    </tr>
  `;
}

function createTransactionTableBody(transactions) {
    const tableBody = transactions.map(tx => createEachTransactionTableRow(tx)).join('');
    return tableBody;
}

function createEachTransactionTableRow(tx) {
    const value = getTransactionValue(tx);
    const tokenSymbol = getTransactionTokenSymbol(tx);
    const transactionFee = ((parseInt(tx.gasPrice) * parseInt(tx.gasUsed)) / 1e18).toFixed(6);
    const functionName = tx.functionName ? tx.functionName.split('(')[0] : '';
    const tableRow = `
        <tr>
            <td>${tx.type}</td>
            <td>${new Date(tx.timeStamp * 1000).toLocaleString()}</td>
            <td>${tx.hash}</td>
            <td>${functionName}</td>
            <td>${value}</td>
            <td>${tokenSymbol}</td>
            <td>${tx.from}</td>
            <td>${tx.to}</td>
            <td>${tx.contractAddress}</td>
            <!--td>${tx.tokenID ?? 'N/A'}</td-->
            <td>${transactionFee}</td>
        </tr>
        `;
    return tableRow;
}

function getTransactionValue(tx) {
    let value;
    if (['normal', 'internal', 'erc20'].includes(tx.type)) {
        value = getEthOrErc20TransactionValue(tx);
    } else if (tx.type === 'erc721') {
        value = 1;
    } else if (tx.type === 'erc1155') {
        value = tx.tokenValue;
    }
    return value;
}

function getEthOrErc20TransactionValue(tx) {
    const decimal = tx.type === 'erc20' && tx.tokenDecimal !== 'N/A' ? tx.tokenDecimal : 18;
    const value = (parseInt(tx.value) / Math.pow(10, decimal)).toFixed(6);
    return value;
}

function getTransactionTokenSymbol(tx) {
    if (['internal', 'normal'].includes(tx.type)) {
        return 'ETH';
    } else if (tx.type === 'erc20') {
        return tx.tokenSymbol || 'N/A';
    } else if (['erc721', 'erc1155'].includes(tx.type)) {
        return `${tx.tokenSymbol}-${tx.tokenID}`;
    }
}
</script>
</html>
